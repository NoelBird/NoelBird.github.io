# leet code



## 995 - Serialize and Deserialize Binary Tree



### serialize

serialize는 DFS(preorder traversal)로 serialize



### deserialize

deserialize는 DFS(preorder traversal)로 deserialize

- 중첩함수의 함수 원형
  - Info deserializeInternal(int idx)
  - idx는 class 내부에 serialized_string이 있고, 그 string의 index입니다.
  - Info 구조체
    - TreeNode* node
    - int idx
  - input으로 들어가는 idx

deserialize는 좀 비효율이 있는 것 같습니다.

string을 매 함수마다 전달하고 싶지 않아서, Info라는 구조체를 만들었습니다.



- 1차 수정 후에 memory 공간효율은 좋아졌지만, 속도는 느려졌음







=== "C++ time(beats 46.28%), space(40.82%)"

    ```c++
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     TreeNode *left;
     *     TreeNode *right;
     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
     * };
     */
    
    #include<string>
    #include<iostream>
    
    using namespace std;
    
    struct Info {
        TreeNode* node;
        int idx;
    };
    
    class Codec {
    public:
    
        // Encodes a tree to a single string.
        string serialize(TreeNode* root) {
            //preorder traversal
    
            string result;
            //serialize root
            if(root)
            {
                result += to_string(root->val) + ",";
            }else
            {
                result += "#,";
                return result;
            }
            //traverse left
            result += serialize(root->left);
            //traverse right
            result += serialize(root->right);
    
            return result;
        }
    
        // Decodes your encoded data to tree.
        TreeNode* deserialize(string data) {
            _str = data;
            if(data == "") return nullptr;
    
            // if root is null, then return
            // if root is not null and left is null, then new node of root
            // 
            return deserializeInternal(0).node;
        }
    
        Info deserializeInternal(int idx){
    
            // process root
            Info rootInfo = getNode(idx);
            if(!rootInfo.node)
            {
                return rootInfo;
            }
            printf("node: %d\n", rootInfo.node->val);
            printf("idx: %d\n", rootInfo.idx);
    
            // process left
            Info leftInfo = deserializeInternal(rootInfo.idx);
            rootInfo.node->left = leftInfo.node;
    
            // process right
            Info rightInfo = deserializeInternal(leftInfo.idx);
            rootInfo.node->right = rightInfo.node;
    
            Info returnInfo;
            returnInfo.node = rootInfo.node;
            returnInfo.idx = rightInfo.idx;
    
            return returnInfo;
        }
    
        Info getNode(int idx)
        {
            char a[6]={0,};
            int i=0;
            while(true)
            {
                if(_str[idx+i] == ',' || _str[idx+i] == NULL)
                    break;
                a[i] = _str[idx+i];
                i++;
            }
    
            Info info;
            if(_str[idx] == '#')
            {
                info.node = nullptr;
            }else
            {
                info.node = new TreeNode(atoi(a));
            }
            info.idx = idx + i + 1;
            return info;
        }
    
    private:
        string _str;
    };
    
    // Your Codec object will be instantiated and called as such:
    // Codec ser, deser;
    // TreeNode* ans = deser.deserialize(ser.serialize(root));
    ```



=== "C++ 1차 수정. serializer. time(beats 27.53%) space(beats 62.74%)"

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

#include<string>
#include<iostream>

using namespace std;

struct Info {
    TreeNode* node;
    int idx;
};

class Codec {
public:
    
    void serializeHelper(TreeNode* root)
    {
        //preorder traversal
        
        //serialize root
        if(root)
        {
            _str += to_string(root->val) + " ";
        }else
        {
            _str += "# ";
            return;
        }
        //traverse left
        serializeHelper(root->left);
        //traverse right
        serializeHelper(root->right);
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        serializeHelper(root);
        return _str;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        _str = data;
        if(data == "") return nullptr;
        
        // if root is null, then return
        // if root is not null and left is null, then new node of root
        // 
        return deserializeInternal(0).node;
    }
    
    Info deserializeInternal(int idx){
        
        // process root
        Info rootInfo = getNode(idx);
        if(!rootInfo.node)
        {
            return rootInfo;
        }
        
        // process left
        Info leftInfo = deserializeInternal(rootInfo.idx);
        rootInfo.node->left = leftInfo.node;
        
        // process right
        Info rightInfo = deserializeInternal(leftInfo.idx);
        rootInfo.node->right = rightInfo.node;
        
        Info returnInfo;
        returnInfo.node = rootInfo.node;
        returnInfo.idx = rightInfo.idx;
        
        return returnInfo;
    }
    
    Info getNode(int idx)
    {
        char a[6]={0,};
        int i=0;
        while(true)
        {
            if(_str[idx+i] == ' ' || _str[idx+i] == NULL)
                break;
            a[i] = _str[idx+i];
            i++;
        }

        Info info;
        if(_str[idx] == '#')
        {
            info.node = nullptr;
        }else
        {
            info.node = new TreeNode(atoi(a));
        }
        info.idx = idx + i + 1;
        return info;
    }

private:
    string _str;
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```



=== "C++ 2차수정. deserializer. time(beats 36.14%), space(beats 67.78%)"

    ```c++
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     TreeNode *left;
     *     TreeNode *right;
     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
     * };
     */
    
    #include<string>
    #include<iostream>
    
    using namespace std;
    
    struct Info {
        TreeNode* node;
        int idx;
    };
    
    class Codec {
    public:
    
        void serializeHelper(TreeNode* root)
        {
            //preorder traversal
    
            //serialize root
            if(root)
            {
                _str += to_string(root->val) + " ";
            }else
            {
                _str += "# ";
                return;
            }
            //traverse left
            serializeHelper(root->left);
            //traverse right
            serializeHelper(root->right);
        }
        // Encodes a tree to a single string.
        string serialize(TreeNode* root) {
            serializeHelper(root);
            return _str;
        }
    
        // Decodes your encoded data to tree.
        TreeNode* deserialize(string data) {
            _iss = istringstream(data);
            return deserializeInternal();
        }
    
        TreeNode* deserializeInternal(){
    
            // process root
            string w;
            _iss >> w;
            if(w == "#") return nullptr;
    
            TreeNode* root = new TreeNode(stoi(w));
    
            // process left
            root->left = deserializeInternal();
    
            // process right
            root->right = deserializeInternal();
    
            return root;
        }
    
    private:
        string _str;
        istringstream _iss;
    };
    
    // Your Codec object will be instantiated and called as such:
    // Codec ser, deser;
    // TreeNode* ans = deser.deserialize(ser.serialize(root));
    ```



=== "C++ 다른 사람의 코드 time(64.72%), space(beats 72.47%)"

    ```c++
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     TreeNode *left;
     *     TreeNode *right;
     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
     * };
     */
    
    class Codec {
    public:
    
        // Encodes a tree to a single string.
        string serialize(TreeNode* root) {
            stringstream ss;
            serialize_helper(root,ss);
            return ss.str();
        }
    
        void serialize_helper(TreeNode* root,stringstream& ss){
            if(!root) ss<<"# ";
            else{
                ss<<root->val<<" ";
                serialize_helper(root->left,ss);
                serialize_helper(root->right,ss);
            }
        }
    
        // Decodes your encoded data to tree.
        TreeNode* deserialize(string data) {
            stringstream ss(data);
            return deserialize_helper(ss);
        }
    
        TreeNode* deserialize_helper(stringstream& ss){
            string val="";
            ss>>val;
            if(val=="#") return nullptr;
            TreeNode* root=new TreeNode(stoi(val));
            root->left=deserialize_helper(ss);
            root->right=deserialize_helper(ss);
            return root;
        }
    };
    
    // Your Codec object will be instantiated and called as such:
    // Codec ser, deser;
    // TreeNode* ans = deser.deserialize(ser.serialize(root));
    ```



이것보다 좀 더 최적화 하려면, stringstream을 직접 for loop 돌게 하면 됩니다.
